* 在字符串列中存储 JSON 格式字符串的优势：
** 自动验证存储在 JSON 列中的 JSON 文件，无效的文件会报错。
** 优化存储格式。JSON 文件存储在 JSON 列中会转换为内部格式，允许快速读取访问文件元素。当服务器要读取用二进制格式存储的 JSON 值时，不需要从文本表示来解析值。二进制格式是结构化的，以使服务器通过键或数组索引来直接查阅子对象或嵌套值，而不用在它们在文件中之前或之后读取所有值。
* 存储在 JSON 列中的 JSON 文件大小受限于系统变量 max_allowed_packet 的值。(当服务器在内部存储器操作 JSON 值时，它可以更大，当服务器存储它时，限制适用。)
* JSON 列不能有默认值。
* JSON 列像其它二进制类型的列一样，没有直接索引；相反，可以在生成的列上创建索引来从 JSON 列提取一个标量值。

==创建 JSON 值==
* 一个 JSON 数组包含一个以逗号分隔和封闭在 [ 和 ] 符号内的值的列表：
<source lan='mysql'>
["abc", 10, null, true, false]
</source>
* 一个 JSON 对象包含一组以逗号分隔和封闭在 { 和 } 符号内的键值对：
<source lan='mysql'>
{"k1": "value", "k2": 10}
</source>
* 举例说明，JSON 数组和对象可以包含字符串或数字，JSON null 常量，JSON 布尔 ture 或 false 的标量值。JSON 对象中的键必须为字符串。时间的标量值也是允许的(date, time 和 datetime)：
<source lang='mysql'>
["12:18:29.000000", "2015-07-29", "2015-07-29 12:18:29.000000"]
</source>
* 在 JSON 数组元素和 JSON 对象键值中允许嵌套：
<source lang='mysql'>
[99, {"id": "HK500", "cost": 75.99}, ["hot", "cold"]]
{"k1": "value", "k2": [10, 20]}
</source>
* 也可以通过 MySQL 提供的一系列函数来获取 JSON 值，以及通过使用 CAST(value AS JSON) 将其它类型值投射到 JSON 类型。
* 以下章节介绍 MySQL 如何处理作为输入的 JSON 值。
* 在 MySQL 中 JSON 写做字符串。MySQL 分析用于环境中的任何字符串都需要一个 JSON 值，且如果不是有效的 JSON 将报错。这些环境包括插入值到有 JSON 数据类型的列中和传递变量给一个期待 JSON 值的函数，如下所示：
** 有效的 JSON 值插入 JSON 列时会成功，如果是无效的会失败：
<source lang='mysql'>
mysql> CREATE TABLE t1 (jdoc JSON);
Query OK, 0 rows affected (0.20 sec)

mysql> INSERT INTO t1 VALUES('{"key1": "value1", "key2": "value2"}');
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO t1 VALUES('[1, 2,');
ERROR 3140 (22032) at line 2: Invalid JSON text: "Invalid value." at position 6 in value (or column) '[1, 2,'.
</source>
** JSON_TYPE() 函数期待一个 JSON 参数并尝试解析为 JSON 值。如果它是有效的将返回值的 JSON 类型，否则将报错：
<source lang='mysql'>
mysql> SELECT JSON_TYPE('["a", "b", 1]');
+----------------------------+
| JSON_TYPE('["a", "b", 1]') |
+----------------------------+
| ARRAY                      |
+----------------------------+

mysql> SELECT JSON_TYPE('"hello"');
+----------------------+
| JSON_TYPE('"hello"') |
+----------------------+
| STRING               |
+----------------------+

mysql> SELECT JSON_TYPE('hello');
ERROR 3146 (22032): Invalid data type for JSON data in argument 1
to function json_type; a JSON string or JSON type is required.
</source>
* MySQL 在 JSON 语境中使用 utf8mb4 字符集和 utf8mb4_bin collation 处理字符串。其它字符集的字符串转换为 utf8mb4 是有必要的。
* JSON_ARRAY() 需要一个值的列表（可能是空的）并返回一个包含那些值的数组：
<source lang='mysql'>
mysql> SELECT JSON_ARRAY('a', 1, NOW());
+----------------------------------------+
| JSON_ARRAY('a', 1, NOW())              |
+----------------------------------------+
| ["a", 1, "2015-07-27 09:43:47.000000"] |
+----------------------------------------+
</source>
* JSON_OBJECT() 需要一列键值对（可能是空的）并返回一个包含那些键值对的 JSON 对象：
<source lang='mysql'>
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc');
+---------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc') |
+---------------------------------------+
| {"key1": 1, "key2": "abc"}            |
+---------------------------------------+
</source>
* JSON_MERGE() 需要两个或更多 JSON 文件，并返回一个组合的结果：
<source lang='mysql'>
mysql> SELECT JSON_MERGE('["a", 1]', '{"b": 2, "c": 3}');
+--------------------------------------------+
| JSON_MERGE('["a", 1]', '{"b": 2, "c": 3}') |
+--------------------------------------------+
| ["a", 1, {"b": 2, "c": 3}]                 |
+--------------------------------------------+
1 row in set (0.01 sec)

mysql> SELECT JSON_MERGE('{"a": 1, "b": 2}', '["c", 3]');
+--------------------------------------------+
| JSON_MERGE('{"a": 1, "b": 2}', '["c", 3]') |
+--------------------------------------------+
| [{"a": 1, "b": 2}, "c", 3]                 |
+--------------------------------------------+
1 row in set (0.00 sec)
</source>
* JSON 值可以分配给自定义变量：
<source lang='mysql'>
mysql> SET @j = JSON_OBJECT('key', 'value');
mysql> SELECT @j;
+------------------+
| @j               |
+------------------+
| {"key": "value"} |
+------------------+
</source>
* 然而自定义变量不能成为 JSON 数据类型，所以虽然前面的 @j 看起来像是 JSON 值，并与 JSON 值有相同的字符集和 collation，它没有 JSON 数据类型。相反，将 JSON_OBJECT() 分配给一个变量的结果是将其转换为一个字符串。
* 转换 JSON 值产生的字符串有字符集 utf8mb4 和 collation 为 utf8mb4_bin：
<source lang='mysql'>
mysql> SELECT CHARSET(@j), COLLATION(@j);
+-------------+---------------+
| CHARSET(@j) | COLLATION(@j) |
+-------------+---------------+
| utf8mb4     | utf8mb4_bin   |
+-------------+---------------+
</source>
* 因为 utf8mb4_bin 是二进制 collation，JSON 值的比较是大小写敏感的：
<source lang='mysql'>
mysql> SELECT JSON_ARRAY('x') = JSON_ARRAY('X');
+-----------------------------------+
| JSON_ARRAY('x') = JSON_ARRAY('X') |
+-----------------------------------+
|                                 0 |
+-----------------------------------+
</source>
* 大小写敏感也适用于 JSON 的 null, true 和 false 常量，永远应该被小写：
<source lang='mysql'>
mysql> SELECT JSON_VALID('null'), JSON_VALID('Null'), JSON_VALID('NULL');
+--------------------+--------------------+--------------------+
| JSON_VALID('null') | JSON_VALID('Null') | JSON_VALID('NULL') |
+--------------------+--------------------+--------------------+
|                  1 |                  0 |                  0 |
+--------------------+--------------------+--------------------+

mysql> SELECT CAST('null' AS JSON);
+----------------------+
| CAST('null' AS JSON) |
+----------------------+
| null                 |
+----------------------+
1 row in set (0.00 sec)

mysql> SELECT CAST('NULL' AS JSON);
ERROR 3141 (22032): Invalid JSON text in argument 1 to function cast_as_json:
"Invalid value." at position 0 in 'NULL'.
</source>
* JSON 常量的大小写敏感不同于 SQL 的 NULL, TRUE 和 FALSE 常量，SQL 的这些常量可以用 lettercase 来写：
<source lang='mysql'>
mysql> SELECT ISNULL(null), ISNULL(Null), ISNULL(NULL);
+--------------+--------------+--------------+
| ISNULL(null) | ISNULL(Null) | ISNULL(NULL) |
+--------------+--------------+--------------+
|            1 |            1 |            1 |
+--------------+--------------+--------------+
</source>

==规范化、合并和自动封装 JSON 值==
* 当一个字符串被解析过的且是一个有效的 JSON 文件，它也是规范化的：
通过接下来的 JSON_OBJECT() 调用生成的对象值不包含第二个 key1 元素，因为这个键名字之前出现过：
<source lang='mysql'>
mysql> SELECT JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def');
+------------------------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def') |
+------------------------------------------------------+
| {"key1": 1, "key2": "abc"}                           |
+------------------------------------------------------+
</source>
* MySQL 的规范化执行也将 JSON 对象的键进行排序（为了使查找更高效）。排序的结果是有变化的，不保证在整改版本都保持一致。原始文件中的键、值和元素之间的空白将被丢弃。
* 产生 JSON 值的 MySQL 函数永远返回规范的值。
* 在结合多个数组的环境中，通过串联数组将多个数组合并为一个数组：
<source lang='mysql'>
mysql> SELECT JSON_MERGE('[1, 2]', '["a", "b"]', '[true, false]');
+-----------------------------------------------------+
| JSON_MERGE('[1, 2]', '["a", "b"]', '[true, false]') |
+-----------------------------------------------------+
| [1, 2, "a", "b", true, false]                       |
+-----------------------------------------------------+
</source>
* 多个对象合并为一个对象，当多个对象的键相同时，该键的值在合并产生的对象中是一个包含这些键的值的数组：
<source lang='mysql'>
mysql> SELECT JSON_MERGE('{"a": 1, "b": 2}', '{"c": 3, "a": 4}');
+----------------------------------------------------+
| JSON_MERGE('{"a": 1, "b": 2}', '{"c": 3, "a": 4}') |
+----------------------------------------------------+
| {"a": [1, 4], "b": 2, "c": 3}                      |
+----------------------------------------------------+
</source>
* 用在需要数组值的环境中的非数组值是自动封装的：值被 [ 和 ] 符号包起来来将其转换为一个数组。下面语句中，每个参数自动封装为一个数组([1], [2])。然后这些合并以生成一个单独的数组（注意字符串的写法）：
<source lang='mysql'>
mysql> SELECT JSON_MERGE('1', '2');
+----------------------+
| JSON_MERGE('1', '2') |
+----------------------+
| [1, 2]               |
+----------------------+

mysql> SELECT JSON_MERGE('1', '2', '"A"');
+-----------------------------+
| JSON_MERGE('1', '2', '"A"') |
+-----------------------------+
| [1, 2, "A"]                 |
+-----------------------------+
</source>
* 数组和对象的合并是通过将对象自动封装为数组，再将两个数组合并：
<source lang='mysql'>
mysql> SELECT JSON_MERGE('[10, 20]', '{"a": "x", "b": "y"}');
+------------------------------------------------+
| JSON_MERGE('[10, 20]', '{"a": "x", "b": "y"}') |
+------------------------------------------------+
| [10, 20, {"a": "x", "b": "y"}]                 |
+------------------------------------------------+
</source>

==搜索和修改 JSON 值==
* JSON 路径表达式在 JSON 文件中选择值。
* 路径表达式可以提取部分或修改一个 JSON 文件，指定要在该文件中操作的位置。下例的查询语句从 JSON 文件中提取键为 name 的成员的值：
<source lang='mysql'>
mysql> SELECT JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name');
+---------------------------------------------------------+
| JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name') |
+---------------------------------------------------------+
| "Aztalan"                                               |
+---------------------------------------------------------+
</source>
* 路径语法使用一个领头的 $ 符号表示在考虑提取的 JSON 文件，接下来的选择器指示文件的更具体的部分：
** 在一个键名称后的一个期间，使用给定的键命名对象中的成员。键名必须指定在双引号中，在路径表达式中如果键名没有放在引号中是不合法的。
** [N] 附加到一个选择一个数组名，在数组中位置 N 的值的路径。数组的位置是从 0 开始的整数。
** 路径可以包含 * 和 ** 通配符：
*** .[*] 相当于一个 JSON 对象中所有成员的值。
*** [*] 相当于 JSON 数组中所有元素的值。
*** prefix**suffix 相当于以 prefix 开始以 suffix 结束的路径。
** 在文件中不存在的路径相当于 NULL。
* 让 $ 相当于有三个元素的 JSON 数组：
<source lang='mysql'>
[3, {"a": [5, 6], "b": 10}, [99, 100]]
</source>
** $[0] 相当于 3，$[1] 相当于 {"a": [5, 6], "b": 10}，$[3] 相当于 NULL。
* 因为 $[1] 和 $[2] 是非标量值，它们可以被用作选择嵌套值的更具体的路径表达式的基础：
** $[1].a 相当于 [5, 6]。
** $[1].a[1] 相当于 6。
** $[1].b 相当于 10。
** $[2][0] 相当于 99。
* 如果路径表达式中未被引号引起来的键名称是非法的，该名称键的路径组件必须被引起来。让 $ 相当于以下值：
<source lang='mysql'>
{"a fish": "shark", "a bird": "sparrow"}
</source>
** 键都包含空格，必须被引起来：
*** $."a fish" 相当于 shark。
*** $."a bird" 相当于 sparrow。
* 使用通配符的路径相当于一个可以包含多个值的数组
<source lang='mysql'>
mysql> SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*');
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*') |
+---------------------------------------------------------+
| [1, 2, [3, 4, 5]]                                       |
+---------------------------------------------------------+
mysql> SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]');
+------------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]') |
+------------------------------------------------------------+
| [3, 4, 5]                                                  |
+------------------------------------------------------------+
</source>
* 下例中，$**.b 相当于多个路径（$.a.b 和 $.c.b），并生成一个匹配到的路径值的数组：
<source lang='mysql'>
mysql> SELECT JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b');
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b') |
+---------------------------------------------------------+
| [1, 2]                                                  |
+---------------------------------------------------------+
</source>
* 下面介绍的函数取一个 JSON 文档，以某种方式修改它后返回修改后的结果。路径表达式指出要修改的地方。
* JSON_SET(), JSON_INSERT() 和 JSON_REPLACE() 函数在处理存在或不存在的路径方面有所不同：
<source lang='mysql'>
mysql> SET @j = '["a", {"b": [true, false]}, [10, 20]]';
</source>
* JSON_SET() 为存在的路径替换值，为不存在的路径添加新值：
<source lang='mysql'>
mysql> SELECT JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+--------------------------------------------+
| JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+--------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20, 2]]      |
+--------------------------------------------+
</source>
* JSON_INSERT() 添加新值但并不替换存在的值：
<source lang='mysql'>
mysql> SELECT JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+-----------------------------------------------+
| JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+-----------------------------------------------+
| ["a", {"b": [true, false]}, [10, 20, 2]]      |
+-----------------------------------------------+
</source>
* JSON_REPLACE() 替换存在的值但忽略新值：
<source lang='mysql'>
mysql> SELECT JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+------------------------------------------------+
| JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+------------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20]]             |
+------------------------------------------------+
</source>
* JSON_REMOVE() 取一个 JSON 文件和一个或多个指定要从文档删除的值的路径：
<source lang='mysql'>
mysql> SELECT JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]');
+---------------------------------------------------+
| JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]') |
+---------------------------------------------------+
| ["a", {"b": [true]}]                              |
+---------------------------------------------------+
</source>
* 该路径有以下影响：
** $[2] 匹配到 [10, 20] 并删除它。
** 第一个 $[1].b[1] 匹配到 b 元素中的 false 并删除它。
** 第二个 $[1].b[1] 什么都没有匹配到：该元素已被删除，该路径不再存在，没有影响。

==JSON 值的比较和排序==
* JSON 值可以使用  =, <, <=, >, >=, <>, != 和 <=> 运算符进行比较。
* 这些比较运算符和函数还没有支持 JSON 值：BETWEEN，IN()，GREATEST()，LEAST()。对于列出的这些比较运算符和函数，一个变通方法是将 JSON 值投射到一个本地的 MySQL 数字或字符串数据类型，这样它们就有了一致的非 JSON 标量类型。
* JSON 值的比较发生在两个层次。比较的第一个层次基于比较的值的 JSON 类型。如果类型不同，比较结果由哪一个类型具有更高的优先权来唯一确定。如果两个值由相同的 JSON 类型，使用类型特定规则来执行比较的第二层次。
* 以下列表展示 JSON 的优先权，从最高到最低（类型名均为函数 JSON_TYPE() 返回的名字）。同一行的类型具有一样的优先权。具有高优先权的类型的任何值都大于具有低优先权类型的任何值。
<source lang='mysql'>
BLOB
BIT
OPAQUE
DATETIME
TIME
DATE
BOOLEAN
ARRAY
OBJECT
STRING
INTEGER, DOUBLE
NULL
</source>
* 对于具有同样优先权的 JSON 值，类型特定的比较规则如下：
** BLOB：两个值的头 N 个字节进行比较，N 是较短的值的字节数。若两个值的头 N 个字节相同，则较短的值排在较长的值前面。
** BIT：与 BLOB 规则相同。
** OPAQUE：与 BLOB 规则相同。OPAQUE 类型的值不被归类为其它类型之一。
** DATETIME：表示时间较早的一个点的值排在表示时间较晚的点的值之前。若两个值最初来自 MySQL 的 DATETIME 和 TIMESTAMP 类型，如果它们表示的是同一时间点，则它们相等。
** TIME：两个时间值中较小的一个排在较大的那个之前。
** DATE：更早的日期排在更近的日期之前。
** ARRAY：如果两个 JSON 数组有相同的长度且数组中对应位置的值相等则这两个 JSON 数组相等。如果两个数组不相等，则它们的顺序取决于数组中有不同之处的第一个位置的元素。在该位置上的值更小的数组排在前面。若较短数组中的所有值都与较长数组中相应位置的值相等，较短数组排在前面。见下例：
<source lang='mysql'>
[] < ["a"] < ["ab"] < ["ab", "cd", "ef"] < ["ab", "ef"]
</source>
** BOOLEAN：JSON 中 false 比 true 要小。
** OBJECT：如果两个 JSON 对象有相同的键的集合，并且在所有对象中每个键有相同的值，则它们相等。不相等的两个对象的顺序是未指定的，但是确定性的。例：
<source lang='mysql'>
{"a": 1, "b": 2} = {"b": 2, "a": 1}
</source>
** STRING：字符串按要进行比较的两个字符串的 utf8mb4 表现形式的头 N 个字节的词汇顺序排序，N 是较短的字符串的长度。若两个字符串的头 N 个字节相同，则认为较短的字符串比较长的字符串要小。例：
<source lang='mysql'>
"a" < "ab" < "b" < "bc"
</source>
*** 这种排序相当于 collation 是 utf8mb4_bin 的 SQL 字符串的排序。因为 utf8mb4_bin 是二进制 collation，JSON 值的比较是大小写敏感的：
<source lang='mysql'>
"A" < "a"
</source>
** INTEGER, DOUBLE：JSON 值内的数字比较与 MySQL 中原生数值类型的比较有一点不同：
*** 在使用 MySQL 原生的 INT 和 DOUBLE 数值类型的两个列之间的比较，所有的比较包含一个 integer 和一个 double 是已知的，所以所有行中 integer 都转换为 double。即，精确值转换为近似值。
*** 另一方面，如果比较两个 JSON 列的查询语句中包含数字，无法事先知道数字将是 integer 还是 double。为提供在所有行中最一致的反应，MySQL 将近似值转换为精确值。这样产生的结果是一致的并且不丢失精确值的精度。
*** 在 JSON 比较中使用非 JSON 数值的比较规则，可能发生不一致的顺序。对数字来说通常的 MySQL 排序规则产生这样的排序：
**** integer 比较：
<source lang='mysql'>
9223372036854775805 < 9223372036854775806 < 9223372036854775807
</source>
**** Double 比较：
<source lang='mysql'>
9223372036854775805 = 9223372036854775806 = 9223372036854775807 = 9.223372036854776e18
</source>
* 对于任何 JSON 值与 SQL 中 NULL 的比较，结果是 UNKNOWN。
* 对于 JSON 值和 非 JSON 值的比较，非 JSON 值根据一定规则转换为 JSON 值再进行比较。
* 对于 JSON 值来说 ORDER BY 和 GROUP BY 根据以下原则工作：
** 标量 JSON 值的排序使用与之前所述一样的规则。
** 对于升序，SQL 的 NULL 排在所有 JSON 值之前，包括 JSON 的 null。对于降序来说，SQL 的 NULL 排在所有 JSON 值之后，包括 JSON 的 null。
** JSON 值的排序键通过系统变量 max_sort_length 的值绑定，所以键的差别仅在第一个 max_sort_length 字节比较为相等之后。？？毛意思啊？？？
** 非标量值的排序目前还不支持。
* 对于排序来说，将 JSON 标量投射到其它原生 MySQL 类型是有益的。例如：如果一个名为 jdoc 的包含 JSON 对象的列有一个成员，该成员由一个 id 键和一个非负值组成，使用以下表达式来按 id 值进行排序：
<source lang='mysql'>
ORDER BY CAST(JSON_EXTRACT(jdoc, '$.id') AS UNSIGNED)
</source>
* 如果发生了列定义中使用了与以上 ORDER BY 相同的表达式的情况，MySQL 优化程序将进行识别并考虑为这个查询语句使用索引。

==JSON 值的聚集==
* 对于 JSON 值的聚集来说，SQL 为其它数据类型忽略 NULL 值。非 NULL 值转换为数字类型和聚合，除了 MIN(), MAX() 和 GROUP_CONCAT()。该转换为数字的操作为数字标量的 JSON 值产生一个有意义的结果，虽然可能会发生截断和精度的丢失。